<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Silence Remover</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        display: ['Audiowide', 'cursive'],
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        studio: {
                            bg: '#121212',
                            panel: '#1e1e1e',
                            accent: '#00ff9d',
                            accentHover: '#00cc7d'
                        }
                    },
                    animation: {
                        'pulse-slow': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            background-color: #121212;
            color: #e0e0e0;
            background-image: linear-gradient(0deg, #121212 0%, #1a1a2e 100%);
        }
        .knob-container {
            position: relative;
            display: inline-block;
        }
        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #00ff9d;
            cursor: pointer;
            margin-top: -8px; 
            box-shadow: 0 0 10px rgba(0,255,157,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
            border-radius: 2px;
        }
        .glass-panel {
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Main Studio Container -->
    <div class="w-full max-w-3xl glass-panel rounded-2xl shadow-2xl overflow-hidden border border-gray-800">
        
        <!-- Header -->
        <div class="bg-black/40 p-6 border-b border-gray-700 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 rounded-full bg-studio-accent flex items-center justify-center text-black font-bold text-xl">
                    <i class="fas fa-wave-square"></i>
                </div>
                <div>
                    <h1 class="font-display text-2xl text-studio-accent tracking-wider">SILENCE CUTTER</h1>
                    <p class="text-xs text-gray-400">AI-Logic Gap Remover</p>
                </div>
            </div>
            <div class="text-xs font-mono text-gray-500">v1.0.0 PRO</div>
        </div>

        <!-- Input Section -->
        <div class="p-8 space-y-8">
            
            <!-- Step 1: Upload -->
            <div class="relative group">
                <div class="absolute -inset-0.5 bg-gradient-to-r from-studio-accent to-blue-600 rounded-xl opacity-20 group-hover:opacity-50 transition duration-500 blur"></div>
                <div class="relative bg-studio-panel rounded-xl p-8 text-center border-2 border-dashed border-gray-600 group-hover:border-studio-accent transition-colors cursor-pointer" onclick="document.getElementById('audioInput').click()">
                    <input type="file" id="audioInput" accept="audio/*" class="hidden" onchange="handleFileUpload(this)">
                    <i class="fas fa-cloud-upload-alt text-4xl mb-4 text-gray-400 group-hover:text-studio-accent transition-colors"></i>
                    <h3 class="text-lg font-semibold text-white" id="fileName">Click to Upload Audio</h3>
                    <p class="text-sm text-gray-500 mt-2">Supports MP3, WAV, OGG</p>
                </div>
            </div>

            <!-- Step 2: Controls -->
            <div id="controlsArea" class="hidden bg-black/20 p-6 rounded-xl border border-gray-700">
                <div class="flex flex-col md:flex-row gap-8 items-center justify-between">
                    
                    <!-- The Magic Value Input -->
                    <div class="flex-1 w-full">
                        <label class="block text-sm font-bold text-gray-300 mb-2">
                            REMOVE SILENCE LONGER THAN:
                        </label>
                        <div class="flex items-center gap-4">
                            <input type="number" id="silenceDuration" value="0.5" step="0.1" min="0.1" class="bg-gray-800 text-studio-accent font-mono text-2xl p-3 rounded-lg w-32 text-center border border-gray-600 focus:border-studio-accent outline-none">
                            <span class="text-xl font-display text-gray-400">SECONDS</span>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">Example: <span class="text-gray-300">0.2</span> removes tiny pauses, <span class="text-gray-300">1.0</span> removes long breaks.</p>
                    </div>

                    <!-- Action Button -->
                    <button onclick="processAudio()" id="processBtn" class="bg-studio-accent hover:bg-studio-accentHover text-black font-bold py-4 px-8 rounded-xl shadow-[0_0_20px_rgba(0,255,157,0.3)] transition-all transform active:scale-95 flex items-center gap-2">
                        <i class="fas fa-cut"></i> PROCESS AUDIO
                    </button>
                </div>
            </div>

            <!-- Loading State -->
            <div id="loader" class="hidden flex flex-col items-center justify-center py-4">
                <div class="w-12 h-12 border-4 border-studio-accent border-t-transparent rounded-full animate-spin"></div>
                <p class="text-studio-accent mt-3 font-mono animate-pulse">Analyzing Waveforms...</p>
            </div>

            <!-- Step 3: Result -->
            <div id="resultArea" class="hidden space-y-4">
                <div class="bg-green-500/10 border border-green-500/30 p-4 rounded-lg flex justify-between items-center text-green-400">
                    <div>
                        <span class="block text-xs text-gray-400 uppercase">Original Length</span>
                        <span class="font-mono text-lg" id="origDur">00:00</span>
                    </div>
                    <i class="fas fa-arrow-right text-gray-600"></i>
                    <div class="text-right">
                        <span class="block text-xs text-gray-400 uppercase">New Length</span>
                        <span class="font-mono text-2xl font-bold text-white" id="newDur">00:00</span>
                    </div>
                </div>

                <audio id="audioPlayer" controls class="w-full"></audio>

                <a id="downloadLink" class="block w-full text-center bg-white text-black font-bold py-3 rounded-lg hover:bg-gray-200 transition-colors">
                    <i class="fas fa-download mr-2"></i> DOWNLOAD CLEAN AUDIO (WAV)
                </a>
            </div>

        </div>
    </div>

    <script>
        let audioContext;
        let originalBuffer = null;
        let fileNameStr = "processed_audio";

        function handleFileUpload(input) {
            const file = input.files[0];
            if (!file) return;

            fileNameStr = file.name.split('.')[0] + "_clean";
            document.getElementById('fileName').innerText = file.name;
            document.getElementById('controlsArea').classList.remove('hidden');
            document.getElementById('resultArea').classList.add('hidden');

            // Initialize Audio Context
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                audioContext.decodeAudioData(arrayBuffer, function(buffer) {
                    originalBuffer = buffer;
                    console.log("Audio Loaded. Duration: " + buffer.duration);
                    document.getElementById('origDur').innerText = formatTime(buffer.duration);
                }, function(e) {
                    alert("Error decoding audio file. Please try a different format.");
                });
            };
            reader.readAsArrayBuffer(file);
        }

        async function processAudio() {
            if (!originalBuffer) {
                alert("Please upload an audio file first.");
                return;
            }

            // UI Updates
            const btn = document.getElementById('processBtn');
            const loader = document.getElementById('loader');
            const resultArea = document.getElementById('resultArea');
            
            btn.classList.add('hidden');
            resultArea.classList.add('hidden');
            loader.classList.remove('hidden');

            // Use setTimeout to allow UI to update (Since JS is single threaded)
            setTimeout(() => {
                removeSilence();
            }, 100);
        }

        function removeSilence() {
            const thresholdInput = document.getElementById('silenceDuration').value;
            const minSilenceDuration = parseFloat(thresholdInput); // User input seconds
            
            // Hardcoded Amplitude Threshold (No dB option for user)
            // 0.01 is roughly -40dB, typically considered silence in standard recordings
            const amplitudeThreshold = 0.01; 

            const rawData = originalBuffer.getChannelData(0); // Analyze left channel
            const sampleRate = originalBuffer.sampleRate;
            const minSilenceSamples = minSilenceDuration * sampleRate;
            
            const newSamples = [];
            let silenceStart = 0;
            let isSilent = false;
            let silenceLength = 0;

            // Simple Gate Algorithm
            // We iterate through the buffer. If we find a chunk of silence > user input, we skip it.
            
            // Note: Since multi-channel logic in pure JS loop is complex, 
            // we will create a map of "keep" regions based on Channel 0, 
            // then apply that map to all channels.

            let keepRegions = []; // Pairs of [start, end]
            let currentRegionStart = 0;
            let inSilence = false;
            let currentSilenceStart = 0;

            for (let i = 0; i < rawData.length; i++) {
                const amplitude = Math.abs(rawData[i]);

                if (amplitude < amplitudeThreshold) {
                    if (!inSilence) {
                        inSilence = true;
                        currentSilenceStart = i;
                    }
                } else {
                    if (inSilence) {
                        // Silence ended. Check if it was long enough to cut.
                        const silenceDuration = i - currentSilenceStart;
                        if (silenceDuration > minSilenceSamples) {
                            // Valid cut found. 
                            // Save the region BEFORE this silence.
                            keepRegions.push([currentRegionStart, currentSilenceStart]);
                            currentRegionStart = i; // Start next region from here
                        }
                        inSilence = false;
                    }
                }
            }
            // Add the final chunk
            keepRegions.push([currentRegionStart, rawData.length]);

            // Now reconstruct the buffer
            // Calculate total new length
            let newLength = 0;
            keepRegions.forEach(r => newLength += (r[1] - r[0]));

            if (newLength === 0) {
                alert("Settings too aggressive! Resulting audio is empty.");
                resetUI();
                return;
            }

            // Create new buffer
            const newBuffer = audioContext.createBuffer(
                originalBuffer.numberOfChannels,
                newLength,
                sampleRate
            );

            // Copy data for each channel
            for (let channel = 0; channel < originalBuffer.numberOfChannels; channel++) {
                const oldData = originalBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                let pointer = 0;

                keepRegions.forEach(r => {
                    const start = r[0];
                    const end = r[1];
                    const chunk = oldData.slice(start, end);
                    newData.set(chunk, pointer);
                    pointer += chunk.length;
                });
            }

            finishProcessing(newBuffer);
        }

        function finishProcessing(newBuffer) {
            // Convert Buffer to WAV
            const wavData = bufferToWave(newBuffer, newBuffer.length);
            const blob = new Blob([wavData], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);

            // Update UI
            document.getElementById('loader').classList.add('hidden');
            document.getElementById('processBtn').classList.remove('hidden');
            document.getElementById('resultArea').classList.remove('hidden');

            document.getElementById('newDur').innerText = formatTime(newBuffer.duration);
            
            const player = document.getElementById('audioPlayer');
            player.src = url;

            const dlLink = document.getElementById('downloadLink');
            dlLink.href = url;
            dlLink.download = fileNameStr + ".wav";
        }

        function resetUI() {
            document.getElementById('loader').classList.add('hidden');
            document.getElementById('processBtn').classList.remove('hidden');
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${m}:${s < 10 ? '0' + s : s}.${ms}`;
        }

        // --- Helper: AudioBuffer to WAV ---
        function bufferToWave(abuffer, len) {
            let numOfChan = abuffer.numberOfChannels,
                length = len * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample,
                offset = 0,
                pos = 0;

            // Write WAV Header
            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8); // file length - 8
            setUint32(0x45564157); // "WAVE"

            setUint32(0x20746d66); // "fmt " chunk
            setUint32(16); // length = 16
            setUint16(1); // PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
            setUint16(numOfChan * 2); // block-align
            setUint16(16); // 16-bit (hardcoded in this example)

            setUint32(0x61746164); // "data" - chunk
            setUint32(length - pos - 4); // chunk length

            // Write Interleaved Data
            for(i = 0; i < abuffer.numberOfChannels; i++)
                channels.push(abuffer.getChannelData(i));

            while(pos < len) {
                for(i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][pos])); // clamp
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit
                    view.setInt16(44 + offset, sample, true); // write 16-bit sample
                    offset += 2;
                }
                pos++;
            }

            return buffer;

            function setUint16(data) {
                view.setUint16(pos, data, true);
                pos += 2;
            }
            function setUint32(data) {
                view.setUint32(pos, data, true);
                pos += 4;
            }
        }
    </script>
</body>
</html>
