<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Silent Remover â€” Absolute Premium</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&family=Syncopate:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --accent-primary: #3b82f6; /* Electric Blue */
      --accent-secondary: #8b5cf6; /* Vivid Purple */
      --accent-glow: #60a5fa;
      --bg-deep: #030712;
      --glass-panel: rgba(255, 255, 255, 0.03);
      --glass-border: rgba(255, 255, 255, 0.08);
      --text-main: #f8fafc;
      --text-muted: #94a3b8;
    }

    body {
      margin: 0;
      font-family: 'Space Grotesk', sans-serif;
      background-color: var(--bg-deep);
      color: var(--text-main);
      overflow-x: hidden;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    /* --- BACKGROUND ANIMATION --- */
    .ambient-light {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: -1;
      overflow: hidden;
      background: radial-gradient(circle at 50% 50%, #111 0%, #000 100%);
    }
    .blob {
      position: absolute;
      filter: blur(80px);
      opacity: 0.4;
      animation: float 20s infinite ease-in-out;
    }
    .blob-1 { top: -10%; left: -10%; width: 50vw; height: 50vw; background: var(--accent-primary); animation-delay: 0s; }
    .blob-2 { bottom: -10%; right: -10%; width: 60vw; height: 60vw; background: var(--accent-secondary); animation-delay: -5s; }

    @keyframes float {
      0% { transform: translate(0, 0) rotate(0deg); }
      33% { transform: translate(30px, 50px) rotate(10deg); }
      66% { transform: translate(-20px, 20px) rotate(-5deg); }
      100% { transform: translate(0, 0) rotate(0deg); }
    }

    /* --- TOP BANNER --- */
    .top-banner {
      width: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--glass-border);
      padding: 12px 0;
      position: relative;
      z-index: 10;
      box-shadow: 0 4px 30px rgba(0,0,0,0.5);
    }

    .marquee-container {
      overflow: hidden;
      white-space: nowrap;
      display: flex;
      align-items: center;
    }

    .marquee-content {
      display: inline-block;
      white-space: nowrap;
      animation: scroll-left 25s linear infinite;
      font-family: 'Syncopate', sans-serif;
      font-weight: 700;
      font-size: 0.85rem;
      letter-spacing: 3px;
      color: #fff;
      text-transform: uppercase;
    }
    
    .highlight { color: var(--accent-glow); text-shadow: 0 0 10px var(--accent-primary); }

    @keyframes scroll-left {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }

    /* --- MAIN CARD --- */
    .container {
      margin-top: 60px;
      width: 90%;
      max-width: 850px;
      position: relative;
      z-index: 2;
      margin-bottom: 50px;
    }

    .card {
      background: var(--glass-panel);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border: 1px solid var(--glass-border);
      border-radius: 24px;
      padding: 40px;
      box-shadow: 0 20px 50px -10px rgba(0,0,0,0.5);
    }

    h2 {
      font-family: 'Syncopate', sans-serif;
      text-align: center;
      font-size: 1.8rem;
      margin: 0 0 10px 0;
      letter-spacing: 4px;
      background: linear-gradient(135deg, #fff 0%, #94a3b8 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: uppercase;
    }

    p.subtitle {
      text-align: center;
      color: var(--text-muted);
      margin-bottom: 40px;
      font-size: 0.9rem;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    /* --- CONTROLS --- */
    label {
      color: var(--accent-glow);
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      margin-bottom: 12px;
      display: block;
    }

    /* Custom File Input */
    .file-upload-wrapper {
      position: relative;
      margin-bottom: 30px;
    }
    input[type="file"] {
      width: 100%;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border: 1px dashed var(--accent-secondary);
      border-radius: 12px;
      color: #fff;
      cursor: pointer;
      box-sizing: border-box;
      transition: all 0.3s ease;
      font-family: 'Space Grotesk', sans-serif;
    }
    input[type="file"]:hover {
      background: rgba(139, 92, 246, 0.1);
      border-color: var(--accent-glow);
    }
    input[type="file"]::file-selector-button {
      background: var(--accent-primary);
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      margin-right: 15px;
      cursor: pointer;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: 0.3s;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 25px;
    }

    .input-box {
      background: rgba(0,0,0,0.2);
      padding: 20px;
      border-radius: 16px;
      border: 1px solid var(--glass-border);
      transition: 0.3s;
    }
    .input-box:hover { border-color: rgba(255,255,255,0.2); }

    input[type="number"] {
      width: 100%;
      background: transparent;
      border: none;
      border-bottom: 2px solid #334155;
      color: #fff;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1.5rem;
      font-weight: 300;
      padding: 5px 0;
      outline: none;
      transition: 0.3s;
    }
    input[type="number"]:focus {
      border-color: var(--accent-glow);
    }

    small {
      color: #64748b;
      margin-top: 8px;
      display: block;
      font-size: 0.75rem;
    }

    /* --- BUTTONS --- */
    .action-area {
      margin-top: 40px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    button, .download-btn {
      flex: 1;
      padding: 18px 24px;
      border: none;
      border-radius: 12px;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: white;
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 700;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      text-align: center;
      text-decoration: none;
      box-shadow: 0 10px 20px -5px rgba(59, 130, 246, 0.4);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 180px;
    }

    button:hover:not(:disabled), .download-btn:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 20px 30px -10px rgba(139, 92, 246, 0.5);
    }

    button:disabled {
      background: #1e293b;
      color: #475569;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .download-btn {
      background: linear-gradient(135deg, #10b981, #059669);
      box-shadow: 0 10px 20px -5px rgba(16, 185, 129, 0.4);
      display: none;
    }

    /* --- LOG & AUDIO --- */
    h4 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 30px;
      text-transform: uppercase;
      letter-spacing: 2px;
      border-bottom: 1px solid #333;
      padding-bottom: 5px;
    }

    #log {
      margin-top: 25px;
      padding: 15px;
      border-radius: 8px;
      background: #000;
      border: 1px solid #333;
      font-family: 'Courier New', monospace;
      color: #22c55e;
      font-size: 0.85rem;
      min-height: 20px;
    }

    audio {
      width: 100%;
      height: 45px;
      margin-top: 10px;
      border-radius: 8px;
      opacity: 0.7;
      transition: 0.3s;
    }
    audio:hover { opacity: 1; }

  </style>
</head>
<body>

  <div class="ambient-light">
    <div class="blob blob-1"></div>
    <div class="blob blob-2"></div>
  </div>

  <div class="top-banner">
    <div class="marquee-container">
      <div class="marquee-content">
        <span class="highlight">MADE BY DEEPAK FOR CREATOR HELP</span> &nbsp; /// &nbsp; SYSTEM STATUS: OPTIMAL &nbsp; /// &nbsp; AI AUDIO ENGINE 2099 &nbsp; /// &nbsp; <span class="highlight">NO SERVER UPLOAD</span> &nbsp; /// &nbsp; INSTANT PROCESSING &nbsp; /// &nbsp; <span class="highlight">MADE BY DEEPAK FOR CREATOR HELP</span> &nbsp; /// &nbsp; SYSTEM STATUS: OPTIMAL &nbsp; /// &nbsp;
      </div>
    </div>
  </div>

  <div class="container">
    <div class="card">
      <h2>Silent Remover Pro</h2>
      <p class="subtitle">Next-Gen Client-Side Processing</p>

      <div class="file-upload-wrapper">
        <label>Input Source File</label>
        <input id="file" type="file" accept="audio/*" />
      </div>

      <div class="controls-grid">
        <div class="input-box">
          <label>Min Silence (Sec)</label>
          <input id="minSilence" type="number" step="0.05" value="0.0" min="0.0" />
          <small>Duration to be cut (e.g. 0.0)</small>
        </div>
        <div class="input-box">
          <label>Threshold (RMS)</label>
          <input id="threshold" type="number" step="0.0001" value="0.05" min="0.00001" />
          <small>Sensitivity (Lower = More Sensitive)</small>
        </div>
      </div>

      <div class="action-area">
        <button id="process">Run Processor</button>
        <button id="preview" disabled>Listen Preview</button>
        <a id="downloadLink" class="download-btn">Download Audio</a>
      </div>

      <div id="log"><small>// System Ready...</small></div>

      <h4>Original Audio Spectrum</h4>
      <audio id="orig" controls></audio>
      
      <h4>Processed Output</h4>
      <audio id="out" controls></audio>
    </div>
  </div>

<script>
// --- CORE LOGIC (UNCHANGED) ---

async function readFileAsArrayBuffer(file){
  return await file.arrayBuffer();
}

function rms(buffer, start, end){
  let sum=0, cnt=0;
  for(let i=start;i<end;i++){ const v=buffer[i]; sum+=v*v; cnt++; }
  return Math.sqrt(sum / Math.max(cnt,1));
}

function encodeWAV(buffers, sampleRate){
  const numChannels = buffers.length;
  const length = buffers[0].length;
  const buffer = new ArrayBuffer(44 + length * numChannels * 2);
  const view = new DataView(buffer);
  function writeString(view, offset, string){ for(let i=0;i<string.length;i++) view.setUint8(offset+i,string.charCodeAt(i)); }
  writeString(view,0,'RIFF');
  view.setUint32(4,36 + length * numChannels * 2,true);
  writeString(view,8,'WAVE');
  writeString(view,12,'fmt ');
  view.setUint32(16,16,true);
  view.setUint16(20,1,true);
  view.setUint16(22,numChannels,true);
  view.setUint32(24,sampleRate,true);
  view.setUint32(28,sampleRate * numChannels * 2,true);
  view.setUint16(32,numChannels * 2,true);
  view.setUint16(34,16,true);
  writeString(view,36,'data');
  view.setUint32(40,length * numChannels * 2,true);

  let offset = 44;
  for(let i=0;i<length;i++){
    for(let ch=0; ch<numChannels; ch++){
      let s = Math.max(-1, Math.min(1, buffers[ch][i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      offset += 2;
    }
  }
  return new Blob([view], {type:'audio/wav'});
}

async function processBuffer(audioBuffer, minSilenceSec, rmsThreshold){
  const sr = audioBuffer.sampleRate;
  const channelData = [];
  for(let c=0;c<audioBuffer.numberOfChannels;c++) channelData.push(audioBuffer.getChannelData(c));

  const frameMs = 10; 
  const frameLen = Math.floor(sr * (frameMs/1000));
  const minSilenceFrames = Math.max(1, Math.floor((minSilenceSec*1000)/frameMs));

  const frames = [];
  for(let i=0;i<channelData[0].length;i+=frameLen){
    const start = i;
    const end = Math.min(i+frameLen, channelData[0].length);
    frames.push(rms(channelData[0], start, end));
  }

  const isSilent = frames.map(v => v < rmsThreshold);

  const keepRanges = [];
  let cursorSample = 0;
  let frameIndex=0;

  while(frameIndex < isSilent.length){
    if(isSilent[frameIndex]){
      let j = frameIndex;
      while(j < isSilent.length && isSilent[j]) j++;
      const runLen = j - frameIndex;
      if(runLen >= minSilenceFrames){
        const silenceStartSample = frameIndex * frameLen;
        if(silenceStartSample > cursorSample){
          keepRanges.push([cursorSample, silenceStartSample]);
        }
        cursorSample = j * frameLen;
      }
      frameIndex = j;
    } else {
      frameIndex++;
    }
  }
  if(cursorSample < channelData[0].length){
    keepRanges.push([cursorSample, channelData[0].length]);
  }

  if(keepRanges.length === 0) return null;

  let totalSamples = 0;
  for(const r of keepRanges) totalSamples += (r[1]-r[0]);

  const outChannels = [];
  for(let c=0;c<channelData.length;c++) outChannels.push(new Float32Array(totalSamples));

  let writePos = 0;
  for(const r of keepRanges){
    const [s,e] = r;
    const len = e - s;
    for(let c=0;c<channelData.length;c++){
      outChannels[c].set(channelData[c].subarray(s,e), writePos);
    }
    writePos += len;
  }

  return {channels: outChannels, sampleRate: sr};
}

// UI HANDLERS
const fileInput = document.getElementById('file');
const processBtn = document.getElementById('process');
const previewBtn = document.getElementById('preview');
const minSilenceEl = document.getElementById('minSilence');
const thresholdEl = document.getElementById('threshold');
const log = document.getElementById('log');
const orig = document.getElementById('orig');
const out = document.getElementById('out');
const downloadLink = document.getElementById('downloadLink');

let latestResultBlob = null;
let origURL = null;

fileInput.addEventListener('change', ()=>{
  const f = fileInput.files[0];
  if(!f) return;
  if(origURL) URL.revokeObjectURL(origURL);
  origURL = URL.createObjectURL(f);
  orig.src = origURL;
  log.innerHTML = '<small style="color:#fff">// Source loaded.</small>';
});

processBtn.addEventListener('click', async ()=>{
  const f = fileInput.files[0];
  if(!f){ alert('Please select a file first.'); return; }
  processBtn.disabled = true; processBtn.textContent = 'Analyzing...';
  log.innerHTML = '<small>// Decoding audio stream...</small>';

  try {
    const arrayBuffer = await readFileAsArrayBuffer(f);
    const ac = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1,1,44100);
    const context = new (window.AudioContext || window.webkitAudioContext)();
    const decoded = await context.decodeAudioData(arrayBuffer.slice(0));

    log.innerHTML = `<small>// Stream Info: ${decoded.sampleRate}Hz | ${decoded.numberOfChannels}CH | ${decoded.duration.toFixed(2)}s</small>`;

    const minSilence = parseFloat(minSilenceEl.value) || 0.0;
    const rmsThreshold = parseFloat(thresholdEl.value) || 0.05;

    log.innerHTML += '<br><small>// Processing algorithm running...</small>';
    const processed = await processBuffer(decoded, minSilence, rmsThreshold);
    
    if(!processed){ 
      log.innerHTML += '<br><small style="color:#ef4444">// ERROR: Output is empty (Threshold might be too high).</small>'; 
      processBtn.disabled=false; 
      processBtn.textContent='Run Processor'; 
      return; 
    }

    const wavBlob = encodeWAV(processed.channels, processed.sampleRate);
    latestResultBlob = wavBlob;

    out.src = URL.createObjectURL(wavBlob);
    downloadLink.href = out.src;
    downloadLink.download = 'Processed_Audio_Pro.wav';
    
    downloadLink.style.display = 'inline-flex';
    previewBtn.disabled = false;
    
    const sizeMB = (wavBlob.size/1024/1024).toFixed(2);
    log.innerHTML += `<br><small style="color:#34d399">// SUCCESS. New File Size: ${sizeMB} MB</small>`;
    
  } catch(e) {
    console.error(e);
    log.innerHTML += `<br><small style="color:#ef4444">// SYSTEM ERROR: ${e.message}</small>`;
  }

  processBtn.disabled=false; processBtn.textContent='Run Processor';
});

previewBtn.addEventListener('click', ()=>{
  if(!latestResultBlob) return;
  out.play();
});
</script>
</body>
</html>
            color: #e0e0e0;
            background-image: linear-gradient(0deg, #121212 0%, #1a1a2e 100%);
        }
        .knob-container {
            position: relative;
            display: inline-block;
        }
        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #00ff9d;
            cursor: pointer;
            margin-top: -8px; 
            box-shadow: 0 0 10px rgba(0,255,157,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
            border-radius: 2px;
        }
        .glass-panel {
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Main Studio Container -->
    <div class="w-full max-w-3xl glass-panel rounded-2xl shadow-2xl overflow-hidden border border-gray-800">
        
        <!-- Header -->
        <div class="bg-black/40 p-6 border-b border-gray-700 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 rounded-full bg-studio-accent flex items-center justify-center text-black font-bold text-xl">
                    <i class="fas fa-wave-square"></i>
                </div>
                <div>
                    <h1 class="font-display text-2xl text-studio-accent tracking-wider">SILENCE CUTTER</h1>
                    <p class="text-xs text-gray-400">AI-Logic Gap Remover</p>
                </div>
            </div>
            <div class="text-xs font-mono text-gray-500">v1.0.0 PRO</div>
        </div>

        <!-- Input Section -->
        <div class="p-8 space-y-8">
            
            <!-- Step 1: Upload -->
            <div class="relative group">
                <div class="absolute -inset-0.5 bg-gradient-to-r from-studio-accent to-blue-600 rounded-xl opacity-20 group-hover:opacity-50 transition duration-500 blur"></div>
                <div class="relative bg-studio-panel rounded-xl p-8 text-center border-2 border-dashed border-gray-600 group-hover:border-studio-accent transition-colors cursor-pointer" onclick="document.getElementById('audioInput').click()">
                    <input type="file" id="audioInput" accept="audio/*" class="hidden" onchange="handleFileUpload(this)">
                    <i class="fas fa-cloud-upload-alt text-4xl mb-4 text-gray-400 group-hover:text-studio-accent transition-colors"></i>
                    <h3 class="text-lg font-semibold text-white" id="fileName">Click to Upload Audio</h3>
                    <p class="text-sm text-gray-500 mt-2">Supports MP3, WAV, OGG</p>
                </div>
            </div>

            <!-- Step 2: Controls -->
            <div id="controlsArea" class="hidden bg-black/20 p-6 rounded-xl border border-gray-700">
                <div class="flex flex-col md:flex-row gap-8 items-center justify-between">
                    
                    <!-- The Magic Value Input -->
                    <div class="flex-1 w-full">
                        <label class="block text-sm font-bold text-gray-300 mb-2">
                            REMOVE SILENCE LONGER THAN:
                        </label>
                        <div class="flex items-center gap-4">
                            <input type="number" id="silenceDuration" value="0.5" step="0.1" min="0.1" class="bg-gray-800 text-studio-accent font-mono text-2xl p-3 rounded-lg w-32 text-center border border-gray-600 focus:border-studio-accent outline-none">
                            <span class="text-xl font-display text-gray-400">SECONDS</span>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">Example: <span class="text-gray-300">0.2</span> removes tiny pauses, <span class="text-gray-300">1.0</span> removes long breaks.</p>
                    </div>

                    <!-- Action Button -->
                    <button onclick="processAudio()" id="processBtn" class="bg-studio-accent hover:bg-studio-accentHover text-black font-bold py-4 px-8 rounded-xl shadow-[0_0_20px_rgba(0,255,157,0.3)] transition-all transform active:scale-95 flex items-center gap-2">
                        <i class="fas fa-cut"></i> PROCESS AUDIO
                    </button>
                </div>
            </div>

            <!-- Loading State -->
            <div id="loader" class="hidden flex flex-col items-center justify-center py-4">
                <div class="w-12 h-12 border-4 border-studio-accent border-t-transparent rounded-full animate-spin"></div>
                <p class="text-studio-accent mt-3 font-mono animate-pulse">Analyzing Waveforms...</p>
            </div>

            <!-- Step 3: Result -->
            <div id="resultArea" class="hidden space-y-4">
                <div class="bg-green-500/10 border border-green-500/30 p-4 rounded-lg flex justify-between items-center text-green-400">
                    <div>
                        <span class="block text-xs text-gray-400 uppercase">Original Length</span>
                        <span class="font-mono text-lg" id="origDur">00:00</span>
                    </div>
                    <i class="fas fa-arrow-right text-gray-600"></i>
                    <div class="text-right">
                        <span class="block text-xs text-gray-400 uppercase">New Length</span>
                        <span class="font-mono text-2xl font-bold text-white" id="newDur">00:00</span>
                    </div>
                </div>

                <audio id="audioPlayer" controls class="w-full"></audio>

                <a id="downloadLink" class="block w-full text-center bg-white text-black font-bold py-3 rounded-lg hover:bg-gray-200 transition-colors">
                    <i class="fas fa-download mr-2"></i> DOWNLOAD CLEAN AUDIO (WAV)
                </a>
            </div>

        </div>
    </div>

    <script>
        let audioContext;
        let originalBuffer = null;
        let fileNameStr = "processed_audio";

        function handleFileUpload(input) {
            const file = input.files[0];
            if (!file) return;

            fileNameStr = file.name.split('.')[0] + "_clean";
            document.getElementById('fileName').innerText = file.name;
            document.getElementById('controlsArea').classList.remove('hidden');
            document.getElementById('resultArea').classList.add('hidden');

            // Initialize Audio Context
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                audioContext.decodeAudioData(arrayBuffer, function(buffer) {
                    originalBuffer = buffer;
                    console.log("Audio Loaded. Duration: " + buffer.duration);
                    document.getElementById('origDur').innerText = formatTime(buffer.duration);
                }, function(e) {
                    alert("Error decoding audio file. Please try a different format.");
                });
            };
            reader.readAsArrayBuffer(file);
        }

        async function processAudio() {
            if (!originalBuffer) {
                alert("Please upload an audio file first.");
                return;
            }

            // UI Updates
            const btn = document.getElementById('processBtn');
            const loader = document.getElementById('loader');
            const resultArea = document.getElementById('resultArea');
            
            btn.classList.add('hidden');
            resultArea.classList.add('hidden');
            loader.classList.remove('hidden');

            // Use setTimeout to allow UI to update (Since JS is single threaded)
            setTimeout(() => {
                removeSilence();
            }, 100);
        }

        function removeSilence() {
            const thresholdInput = document.getElementById('silenceDuration').value;
            const minSilenceDuration = parseFloat(thresholdInput); // User input seconds
            
            // Hardcoded Amplitude Threshold (No dB option for user)
            // 0.01 is roughly -40dB, typically considered silence in standard recordings
            const amplitudeThreshold = 0.01; 

            const rawData = originalBuffer.getChannelData(0); // Analyze left channel
            const sampleRate = originalBuffer.sampleRate;
            const minSilenceSamples = minSilenceDuration * sampleRate;
            
            const newSamples = [];
            let silenceStart = 0;
            let isSilent = false;
            let silenceLength = 0;

            // Simple Gate Algorithm
            // We iterate through the buffer. If we find a chunk of silence > user input, we skip it.
            
            // Note: Since multi-channel logic in pure JS loop is complex, 
            // we will create a map of "keep" regions based on Channel 0, 
            // then apply that map to all channels.

            let keepRegions = []; // Pairs of [start, end]
            let currentRegionStart = 0;
            let inSilence = false;
            let currentSilenceStart = 0;

            for (let i = 0; i < rawData.length; i++) {
                const amplitude = Math.abs(rawData[i]);

                if (amplitude < amplitudeThreshold) {
                    if (!inSilence) {
                        inSilence = true;
                        currentSilenceStart = i;
                    }
                } else {
                    if (inSilence) {
                        // Silence ended. Check if it was long enough to cut.
                        const silenceDuration = i - currentSilenceStart;
                        if (silenceDuration > minSilenceSamples) {
                            // Valid cut found. 
                            // Save the region BEFORE this silence.
                            keepRegions.push([currentRegionStart, currentSilenceStart]);
                            currentRegionStart = i; // Start next region from here
                        }
                        inSilence = false;
                    }
                }
            }
            // Add the final chunk
            keepRegions.push([currentRegionStart, rawData.length]);

            // Now reconstruct the buffer
            // Calculate total new length
            let newLength = 0;
            keepRegions.forEach(r => newLength += (r[1] - r[0]));

            if (newLength === 0) {
                alert("Settings too aggressive! Resulting audio is empty.");
                resetUI();
                return;
            }

            // Create new buffer
            const newBuffer = audioContext.createBuffer(
                originalBuffer.numberOfChannels,
                newLength,
                sampleRate
            );

            // Copy data for each channel
            for (let channel = 0; channel < originalBuffer.numberOfChannels; channel++) {
                const oldData = originalBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                let pointer = 0;

                keepRegions.forEach(r => {
                    const start = r[0];
                    const end = r[1];
                    const chunk = oldData.slice(start, end);
                    newData.set(chunk, pointer);
                    pointer += chunk.length;
                });
            }

            finishProcessing(newBuffer);
        }

        function finishProcessing(newBuffer) {
            // Convert Buffer to WAV
            const wavData = bufferToWave(newBuffer, newBuffer.length);
            const blob = new Blob([wavData], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);

            // Update UI
            document.getElementById('loader').classList.add('hidden');
            document.getElementById('processBtn').classList.remove('hidden');
            document.getElementById('resultArea').classList.remove('hidden');

            document.getElementById('newDur').innerText = formatTime(newBuffer.duration);
            
            const player = document.getElementById('audioPlayer');
            player.src = url;

            const dlLink = document.getElementById('downloadLink');
            dlLink.href = url;
            dlLink.download = fileNameStr + ".wav";
        }

        function resetUI() {
            document.getElementById('loader').classList.add('hidden');
            document.getElementById('processBtn').classList.remove('hidden');
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${m}:${s < 10 ? '0' + s : s}.${ms}`;
        }

        // --- Helper: AudioBuffer to WAV ---
        function bufferToWave(abuffer, len) {
            let numOfChan = abuffer.numberOfChannels,
                length = len * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample,
                offset = 0,
                pos = 0;

            // Write WAV Header
            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8); // file length - 8
            setUint32(0x45564157); // "WAVE"

            setUint32(0x20746d66); // "fmt " chunk
            setUint32(16); // length = 16
            setUint16(1); // PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
            setUint16(numOfChan * 2); // block-align
            setUint16(16); // 16-bit (hardcoded in this example)

            setUint32(0x61746164); // "data" - chunk
            setUint32(length - pos - 4); // chunk length

            // Write Interleaved Data
            for(i = 0; i < abuffer.numberOfChannels; i++)
                channels.push(abuffer.getChannelData(i));

            while(pos < len) {
                for(i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][pos])); // clamp
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit
                    view.setInt16(44 + offset, sample, true); // write 16-bit sample
                    offset += 2;
                }
                pos++;
            }

            return buffer;

            function setUint16(data) {
                view.setUint16(pos, data, true);
                pos += 2;
            }
            function setUint32(data) {
                view.setUint32(pos, data, true);
                pos += 4;
            }
        }
    </script>
</body>
</html>
